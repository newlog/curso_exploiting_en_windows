###
# Convertir exploit de WinXPSP3 a Win7SP1.
###

0.1. Comprobar si el exploit final (mcvcore-5.maki) funciona.
    - !break_dll_load in_mod.dll 0x12f02bc3
    [*] Como se puede ver falla al ejecutar la instrucción en el SEH Handler (0x006E6B48)
        - Si se mira el proceso con la app "Process Explorer" de sysinternals se puede
        comprobar como DEP está activado (se ha de añadir la columna).
        - También se puede mostrar en Imm. mostrando la memoria del proceso
          (Alt+m) y buscar la dirección a la que volvemos (0x006E6B48).

0.2. Vemos que no funciona (da una excepción) al ejecutar el primer pop del P/P/R.
--

1. Mantenemos el SE Handler sobrescrito y ponemos un breakpoint en la dirección 
    con la que lo hemos sobrescrito.

2. Calculamos la distancia entre el valor de ESP (0x021B257C) cuando se está 
    ejecutando el Handler y donde podemos encontrar el inicio de nuestro 
    payload (0x021B29D4) en el stack.
    - 0x021B29D4 - 0x021B257C = 0x458

3. Necesitamos un stack pivot de +0x458 bytes como mínimo para poner nuestro ROP payload.
    - !mona find stackpivot
    [!] No hay stackpivots suficientemente grandes en modulos sin SafeSEH!

4. La otra opción sería encontrar: (mostrar gráfico para explicarlo)
    - POP/POP/POP ESP/RET: ESP apuntaría a nSEH y lo que hubiera ahí se
      ejecutaría como un payload ROP. En nSEH se pondría una dirección que hiciera un
      ESP+X/RET para saltar el SEH y seguir con el ROP.
    [!] No hay instrucciones en módulos sin SafeSEH que permitan hacerlo.
---------------------

Faltaría buscar gadgets que bypasearan SafeSEH (unicode.nls, etc)
